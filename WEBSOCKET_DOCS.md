# WebSocket API Документация

## Общая информация

WebSocket используется для реального времени обмена сообщениями в чатах. После подключения клиент и сервер могут отправлять сообщения в обе стороны без необходимости постоянных HTTP запросов.

## Подключение

### URL
```
ws://your-domain.com/chat/{chat_id}/ws
```
или для безопасного соединения:
```
wss://your-domain.com/chat/{chat_id}/ws
```

### Заголовки
```
Authorization: Bearer <your_jwt_token>
```

### Пример подключения (JavaScript)
```javascript
const chatId = 123;
const token = 'your_jwt_token_here';

const ws = new WebSocket(`ws://your-domain.com/chat/${chatId}/ws`);

ws.onopen = () => {
    console.log('WebSocket соединение установлено');
};

ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    handleWebSocketEvent(data);
};

ws.onclose = () => {
    console.log('WebSocket соединение закрыто');
};

ws.onerror = (error) => {
    console.error('WebSocket ошибка:', error);
};
```

## Аутентификация

Авторизация происходит через JWT токен в заголовке `Authorization`. Токен должен быть действительным и пользователь должен быть участником указанного чата.

## Формат сообщений

Все сообщения передаются в формате JSON.

### Общая структура сообщений от клиента:
```json
{
    "type": "тип_события",
    "message": "данные_сообщения",
    "timestamp": 1634567890123
}
```

### Общая структура сообщений от сервера:
```json
{
    "type": "тип_события",
    "message": "данные_сообщения",
    "messages": "массив_данных",
    "user_id": 123,
    "chat_id": 456,
    "timestamp": "2023-10-18T12:30:45Z",
    "message_id": 789,
    "meta": {}
}
```

## События от клиента (клиент → сервер)

### 1. Отправка сообщения
Отправляет текстовое сообщение в чат.

**Тип:** `message`

**Формат:**
```json
{
    "type": "message",
    "message": "Текст сообщения",
    "timestamp": 1634567890123
}
```

**Параметры:**
- `message` (string, обязательный): Текст сообщения, максимум 5000 символов
- `timestamp` (number, опциональный): UNIX timestamp в миллисекундах

**Ограничения:**
- Rate limit: 10 сообщений в секунду
- HTML автоматически экранируется
- Пустые сообщения отклоняются

### 2. Индикатор набора текста
Уведомляет других участников о том, что пользователь печатает сообщение.

**Тип:** `typing`

**Формат:**
```json
{
    "type": "typing",
    "message": "true"
}
```

**Параметры:**
- `message` (string, обязательный): `"true"` или `"false"`

### 3. Подтверждение прочтения
Отмечает сообщение как прочитанное.

**Тип:** `read_receipt`

**Формат:**
```json
{
    "type": "read_receipt",
    "message": "12345"
}
```

**Параметры:**
- `message` (string, обязательный): ID сообщения для отметки прочтения

## События от сервера (сервер → клиент)

### 1. Новое сообщение
Приходит когда кто-то отправил сообщение в чат.

**Тип:** `message`

**Формат:**
```json
{
    "type": "message",
    "message": {
        "id": 12345,
        "chat_id": 456,
        "sender_id": 789,
        "message": "Текст сообщения",
        "type": "text",
        "timestamp": "2023-10-18T12:30:45Z",
        "sender": {
            "id": 789,
            "username": "user123",
            "avatar_url": "..."
        }
    },
    "chat_id": 456,
    "timestamp": "2023-10-18T12:30:45Z"
}
```

### 2. История сообщений
Отправляется при подключении, содержит последние сообщения из чата.

**Тип:** `history`

**Формат:**
```json
{
    "type": "history",
    "messages": [
        {
            "id": 12345,
            "chat_id": 456,
            "sender_id": 789,
            "message": "Привет!",
            "timestamp": "2023-10-18T12:30:45Z",
            "sender": {...}
        },
        // ... другие сообщения
    ],
    "meta": {
        "count": 25,
        "has_more": true
    }
}
```

**Параметры meta:**
- `count` (number): Количество отправленных сообщений
- `has_more` (boolean): Есть ли еще сообщения для загрузки

### 3. Подтверждение отправки
Подтверждение что сообщение было успешно сохранено на сервере.

**Тип:** `message_sent`

**Формат:**
```json
{
    "type": "message_sent",
    "message_id": 12345,
    "timestamp": "2023-10-18T12:30:45Z"
}
```

### 4. Индикатор набора текста от других пользователей
Уведомление о том, что другой пользователь печатает.

**Тип:** `typing`

**Формат:**
```json
{
    "type": "typing",
    "user_id": 789,
    "message": true,
    "chat_id": 456
}
```

### 5. Ошибка
Сообщение об ошибке при обработке запроса клиента.

**Тип:** `error`

**Формат:**
```json
{
    "type": "error",
    "message": "Описание ошибки"
}
```

**Возможные ошибки:**
- `"empty message"` - пустое сообщение
- `"message too long (max 5000 characters)"` - слишком длинное сообщение
- `"rate limit exceeded"` - превышен лимит отправки сообщений
- `"empty event type"` - не указан тип события
- `"unknown event type: <тип>"` - неизвестный тип события
- `"invalid message id"` - неверный ID сообщения
- `"failed to save message"` - ошибка сохранения сообщения

### 6. Информация о комнате
Отправляется при подключении к комнате.

**Тип:** `room_info`

**Формат:**
```json
{
    "type": "room_info",
    "message": {
        "chat_id": 456,
        "active_clients": 3,
        "created_at": "2023-10-18T12:30:45Z",
        "last_activity": "2023-10-18T12:35:45Z"
    }
}
```

### 7. Пользователь присоединился/покинул чат
Уведомления о присутствии пользователей.

**Тип:** `user_joined` или `user_left`

**Формат:**
```json
{
    "type": "user_joined",
    "user_id": 789,
    "chat_id": 456,
    "message": true
}
```

## Жизненный цикл соединения

### 1. Подключение
```
Клиент → Сервер: HTTP Upgrade запрос
Сервер → Клиент: 101 Switching Protocols
Установлено WebSocket соединение
```

### 2. Инициализация
```
Сервер → Клиент: room_info (информация о комнате)
Сервер → Клиент: history (последние сообщения)
```

### 3. Обмен сообщениями
```
Клиент ←→ Сервер: обмен событиями в реальном времени
```

### 4. Пинг-понг
```
Сервер → Клиент: Ping каждые 54 секунды
Клиент → Сервер: Pong (автоматически)
```

### 5. Отключение
```
Любая сторона → Другая сторона: Close frame
Соединение закрыто
```

## Таймауты и лимиты

### Таймауты:
- **Write timeout:** 10 секунд
- **Pong timeout:** 60 секунд
- **Ping interval:** 54 секунды

### Лимиты:
- **Max message size:** 64KB
- **Rate limit:** 10 сообщений в секунду на пользователя
- **Max connections per chat:** 100 одновременных подключений

### Автоматическая очистка:
- Неактивные комнаты (без сообщений >1 час) автоматически удаляются
- Кеш сообщений очищается через 24 часа

## Коды закрытия WebSocket

| Код | Описание |
|-----|----------|
| 1000 | Нормальное закрытие |
| 1001 | Сервер уходит |
| 1002 | Протокольная ошибка |
| 1003 | Неподдерживаемый тип данных |
| 1008 | Нарушение политики |
| 1009 | Слишком большое сообщение |
| 1011 | Внутренняя ошибка сервера |

## Пример полного сценария

### Подключение и отправка сообщения:
```javascript
// 1. Подключение
const ws = new WebSocket('ws://domain.com/chat/123/ws');

// 2. Получение истории
ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === 'history') {
        console.log('Получена история:', data.messages);
    }
    
    if (data.type === 'room_info') {
        console.log('Информация о комнате:', data.message);
    }
};

// 3. Отправка сообщения
function sendMessage(text) {
    const message = {
        type: 'message',
        message: text,
        timestamp: Date.now()
    };
    ws.send(JSON.stringify(message));
}

// 4. Отправка индикатора набора
function sendTypingIndicator(isTyping) {
    const typing = {
        type: 'typing',
        message: isTyping.toString()
    };
    ws.send(JSON.stringify(typing));
}

// 5. Подтверждение прочтения
function markAsRead(messageId) {
    const receipt = {
        type: 'read_receipt',
        message: messageId.toString()
    };
    ws.send(JSON.stringify(receipt));
}
```

## Обработка ошибок

### Пример обработки ошибок:
```javascript
ws.onerror = (error) => {
    console.error('WebSocket error:', error);
    
    // Попытка переподключения
    setTimeout(() => {
        connectWebSocket();
    }, 5000);
};

ws.onclose = (event) => {
    console.log('Connection closed:', event.code, event.reason);
    
    if (event.code !== 1000) {
        // Ненормальное закрытие - переподключение
        setTimeout(() => {
            connectWebSocket();
        }, 3000);
    }
};
```

## Особенности реализации

### Кеширование:
- Последние сообщения кешируются в Redis на 24 часа
- Активные пользователи отслеживаются в реальном времени
- При отключении всех пользователей сообщения сохраняются в БД

### Масштабируемость:
- Поддерживает тысячи одновременных подключений
- Автоматическая балансировка нагрузки между экземплярами
- Статистика и мониторинг доступны через API

### Безопасность:
- Все сообщения проходят HTML экранирование
- Rate limiting предотвращает спам
- Валидация всех входных данных
- JWT аутентификация для каждого соединения

## Тестирование

### Инструменты для тестирования:
1. **Browser DevTools** - встроенные инструменты разработчика
2. **wscat** - CLI инструмент для тестирования WebSocket
   ```bash
   wscat -c "ws://localhost:8080/chat/123/ws" -H "Authorization: Bearer token"
   ```
3. **Postman** - поддержка WebSocket в новых версиях
4. **websocat** - продвинутый CLI инструмент

### Пример теста с wscat:
```bash
# Подключение
wscat -c "ws://localhost:8080/chat/1/ws" -H "Authorization: Bearer eyJhbGciOiJ..."

# Отправка сообщения
> {"type": "message", "message": "Hello"}

# Отправка индикатора набора
> {"type": "typing", "message": "true"}
```

## FAQ

### Q: Что делать при потере соединения?
**A:** Реализовать механизм переподключения с экспоненциальной задержкой.

### Q: Как получить пропущенные сообщения?
**A:** При переподключении сервер отправляет историю сообщений.

### Q: Поддерживаются ли файлы и изображения?
**A:** Да, через поле `type: "image"` или `type: "file"` с `attachment_url`.

### Q: Как отслеживать доставку сообщений?
**A:** Сервер отправляет подтверждение `message_sent` с ID сообщения.

### Q: Можно ли подключиться к нескольким чатам одновременно?
**A:** Да, нужно открыть отдельное соединение для каждого чата.

## Контакты

При возникновении проблем с WebSocket соединением:
1. Проверьте JWT токен
2. Убедитесь что пользователь является участником чата
3. Проверьте не превышены ли лимиты
4. Посмотрите логи сервера для деталей ошибки

---
*Последнее обновление: 2024-01-15*